# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a booking application for Jamboree 2026, built with Gleam and PostgreSQL. It enables participants to book various activities during the event.

## Essential Commands

### Development
```sh
gleam run                          # Run the web server (starts on port 8000)
gleam test                         # Run tests
gleam run -m squirrel              # Regenerate Gleam modules from SQL (run after modifying SQL files)
```

### Database Setup
```sh
# Set database URL
export DATABASE_URL="postgres://postgres@localhost:5432/j26booking"

# Run migrations
gleam run -m cigogne last

# Seed database with example activities
psql "$DATABASE_URL" -f priv/seeding/activities.sql
```

## Architecture

### Tech Stack
- **Web Framework**: Mist + Wisp (Gleam web server)
- **Frontend**: Lustre (SSR) + HTMX + TailwindCSS
- **Database**: PostgreSQL with Squirrel (type-safe queries) and Cigogne (migrations)

### Application Structure

The app uses a supervised architecture with two main components:
1. **Database pool** (`pog.supervised`): Connection pool to PostgreSQL
2. **Web server** (`wisp_mist.supervised`): HTTP server on port 8000

Both are managed by a RestForOne supervisor in `src/j26booking.gleam:36-39`.

### Key Modules

- **`src/j26booking.gleam`**: Entry point, sets up supervision tree and database connection
- **`src/j26booking/router.gleam`**: Request routing and handlers
- **`src/j26booking/web.gleam`**: Middleware configuration and Context type
- **`src/j26booking/components.gleam`**: Lustre components for SSR
- **`src/j26booking/data.gleam`**: Data transformation utilities
- **`src/j26booking/sql.gleam`**: Generated by Squirrel (DO NOT EDIT MANUALLY)

### Database Workflow

1. **Schema changes**: Add SQL files to `priv/migrations/`
2. **Queries**: Add `.sql` files to `src/j26booking/sql/`
3. **Regenerate**: Run `gleam run -m squirrel` to generate type-safe Gleam code in `src/j26booking/sql.gleam`
4. **Apply migrations**: Run `gleam run -m cigogne last`

The database connection is hardcoded to `localhost:5432` with database name `j26booking` and user `postgres` (no password).

### Request Flow

```
Request → web.middleware → router.handle_request → handler functions
                ↓
        (static files, logging, crash recovery)
```

Routes are defined in `src/j26booking/router.gleam:12-17`:
- `/` → redirects to `/index.html`
- `/activities` → lists all activities from database
- `/book/:id` → booking endpoint (placeholder)

### Database Schema (MVP)

Core tables:
- **user**: id, role (organizer/booker/admin)
- **activity**: id, title, description, max_attendees, start_time, end_time
- **booking**: id, user_id, activity_id, group, responsible, phone_number, participant_count
- **activity_user**: many-to-many between activities and organizers

See README.md for detailed schema diagram including extra features.

## Gleam and Functional Programming Best Practices

### Error Handling

- **Always use Result types**: Handle errors explicitly with `Result(a, e)` instead of exceptions
- **Pattern match on Results**: Always pattern match to handle both `Ok` and `Error` cases:
  ```gleam
  case result {
    Ok(value) -> // handle success
    Error(error) -> // handle failure
  }
  ```
- **Use `use` expressions**: Simplify nested Result handling with the `use` syntax:
  ```gleam
  use value <- result.try(operation())
  // Continue with value
  ```
- **Exhaustive pattern matching**: Ensure all cases are handled in `case` expressions to prevent runtime errors

### Type Safety

- **Leverage the type system**: Let the compiler catch errors at compile-time rather than runtime
- **Pattern match on custom types**: Extract data from custom types using pattern matching:
  ```gleam
  pub fn to_string(pokemon: Pokemon) {
    let Pokemon(pokedex_number:, name:) = pokemon
    // Use extracted fields
  }
  ```
- **Avoid underscore variables in logic**: Use meaningful names for clarity; `_` should only be used for truly unused values

### Code Organization

- **Pure functions**: Prefer pure functions that don't produce side effects
- **Small, focused functions**: Break complex operations into smaller, composable functions
- **Use pipelines**: Chain operations with `|>` for clarity:
  ```gleam
  list
  |> list.map(transform)
  |> list.filter(predicate)
  |> list.first
  ```

### Pattern Matching

- **Match early, match often**: Use pattern matching to destructure data at function boundaries
- **Alternative patterns with care**: Ensure all patterns define the same variables
- **Label fields in patterns**: Use labelled fields for clarity: `Person(name:, age:)`

### Best Practices for This Project

- **Use Squirrel for queries**: Never hand-write SQL strings; always use `.sql` files and regenerate with `gleam run -m squirrel`
- **Handle database Results**: Database operations return `Result` types—always handle both success and failure
- **Validate input early**: Pattern match and validate request data at handler entry points
- **Type-safe routing**: Use Wisp's routing helpers to ensure type-safe path parameter extraction

## HTMX Best Practices

HTMX is used in this project for building dynamic, interactive UIs with minimal JavaScript. It works seamlessly with our Lustre SSR components and follows a hypermedia-driven approach.

### Core Patterns Used in This Project

- **HTML fragments**: Endpoints return HTML fragments (via Lustre components), not JSON
- **Progressive enhancement**: Forms work without JS; HTMX enhances them
- **Server-side validation**: Return updated form HTML with validation errors inline
- **Event coordination**: Use `HX-Trigger` response header to coordinate multi-component updates

### Essential Attributes

**Request methods**:
- `hx-get`, `hx-post`, `hx-put`, `hx-patch`, `hx-delete`

**Targeting and swapping**:
- `hx-target`: Where to put response content (`#id`, `.class`, `this`, `closest div`)
- `hx-swap`: How to insert content (`innerHTML`, `outerHTML`, `beforeend`, `afterend`)
- `hx-select`: Extract specific part of response HTML

**Common modifiers**:
- `hx-trigger`: Specify triggering events (e.g., `click`, `keyup changed delay:500ms`)
- `hx-vals`: Add extra data to requests (supports JSON and `js:{...}` for dynamic values)
- `hx-confirm`: Show confirmation dialog before request
- `hx-indicator`: Show loading indicator during request

Example:
```html
<input hx-get="/search"
       hx-trigger="keyup changed delay:300ms"
       hx-target="#results"
       hx-indicator="#loading">
```

### Event Handling

Use `hx-on:<event>` for inline handlers:
```html
<button hx-on:click="console.log('Clicked!')">Click</button>
```

For HTMX lifecycle events, use shorthand `hx-on::<event>`:
```html
<button hx-get="/data" hx-on::before-request="showSpinner()">Load</button>
```

### Key Lifecycle Events

**Most commonly used**:
- `htmx:beforeRequest`: Intercept/cancel requests
- `htmx:afterSwap`: Run code after DOM update
- `htmx:responseError`: Handle server errors

**Less common** (see full list in docs when needed):
- Request lifecycle: `htmx:configRequest`, `htmx:beforeSend`, `htmx:afterRequest`
- Content swapping: `htmx:beforeSwap`, `htmx:afterSettle`, `htmx:load`
- History: `htmx:beforeHistorySave`, `htmx:historyRestore`

### Server-Side Integration with Wisp

When handling HTMX requests in `router.gleam`:

1. **Return HTML fragments** from Lustre components:
   ```gleam
   pub fn handle_activity_list(req: Request, ctx: Context) {
     use activities <- result.try(sql.get_activities(ctx.db))
     let html = components.activity_list(activities)
     response.html(html)
   }
   ```

2. **Use HX-* response headers** to control behavior:
   - `HX-Trigger`: Fire client-side events
   - `HX-Retarget`: Change target element
   - `HX-Reswap`: Override swap strategy

3. **Validation errors**: Return the form with error messages:
   ```gleam
   case validate_booking(form_data) {
     Ok(booking) -> save_and_redirect(booking)
     Error(errors) -> response.html(components.booking_form(form_data, errors))
   }
   ```

### Common Gotchas

- **Form serialization**: Forms automatically serialize; use `hx-include` for additional fields
- **Event bubbling**: Use `consume` modifier to prevent parent handlers from firing
- **Debouncing searches**: Use `changed delay:300ms` to avoid excessive requests
- **Loading states**: Style `.htmx-request` class or use `hx-indicator`

### Accessibility Considerations

- Ensure keyboard navigation works (tab, enter, escape)
- Announce dynamic content changes to screen readers
- Provide visual feedback for loading states
- Don't break browser back button (use `hx-push-url` when appropriate)

## Commit Message Guidelines

This project follows the [Conventional Commits](https://www.conventionalcommits.org/) specification for all git commits.

### Pre-Commit Checklist

**ALWAYS run `gleam format` before committing any code changes.**

### Commit Message Format

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

### Commit Types

- **feat**: A new feature
- **fix**: A bug fix
- **docs**: Documentation only changes
- **style**: Code style changes (formatting, missing semi-colons, etc.)
- **refactor**: Code change that neither fixes a bug nor adds a feature
- **perf**: Performance improvements
- **test**: Adding or correcting tests
- **chore**: Changes to build process or auxiliary tools
- **ci**: Changes to CI configuration files and scripts
- **build**: Changes that affect the build system or dependencies
- **revert**: Reverts a previous commit

### Scope (Optional)

The scope provides additional context about which part of the codebase is affected:
- `router`: Routing and request handling
- `db`: Database queries and migrations
- `sql`: SQL files and Squirrel codegen
- `components`: Lustre UI components
- `api`: API endpoints
- `auth`: Authentication/authorization

Example: `feat(router): add booking endpoint`

### Breaking Changes

Mark breaking changes with `!` after the type/scope:
- `feat!: migrate to new authentication system`
- `feat(api)!: change response format to JSON:API`

Or use a `BREAKING CHANGE:` footer:
```
feat: allow config object to extend other configs

BREAKING CHANGE: `extends` key in config file is now used for extending other config files
```

### Length Standards

- **Subject line**: Maximum 50 characters (hard limit 72)
  - Use imperative mood: "add" not "added" or "adds"
  - Don't capitalize first letter after the colon
  - No period at the end
- **Body**: Wrap at 72 characters per line
  - Explain the "what" and "why" (not "how")
  - Separate from subject with blank line
- **Footer**: For references and breaking changes
  - Examples: `Refs: #123`, `Fixes: #456`, `Reviewed-by: Name`

### Examples

Simple feature:
```
feat: add user authentication
```

Bug fix with scope:
```
fix(router): correct path parameter parsing
```

Documentation:
```
docs: update database setup instructions
```

Breaking change:
```
feat(api)!: change activity response format

Changed from flat structure to nested format with metadata.

BREAKING CHANGE: API clients must update response parsing logic
```

Complex fix with details:
```
fix: prevent racing of requests

Introduce a request id and a reference to latest request. Dismiss
incoming responses other than from latest request.

Remove timeouts which were used to mitigate the racing issue but are
obsolete now.

Refs: #123
```
